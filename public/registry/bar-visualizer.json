{
  "name": "bar-visualizer",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "bar-visualizer/BarVisualizer.vue",
      "content": "{\r\ntype: uploaded file\r\nfileName: iman-mohamadi/enzoui/EnzOUi-481682bc4f3f825c0131815bd4179e5da136063e/app/components/ui/bar-visualizer/BarVisualizer.vue\r\nfullContent:\r\n<script setup lang=\"ts\">\r\nimport { ref, computed, watch, onMounted, onUnmounted, type Ref } from 'vue'\r\nimport { cn } from '@/lib/utils'\r\n\r\n// --- Types ---\r\nexport type AgentState = \"connecting\" | \"initializing\" | \"listening\" | \"speaking\" | \"thinking\"\r\n\r\ninterface AudioAnalyserOptions {\r\n  fftSize?: number\r\n  smoothingTimeConstant?: number\r\n  minDecibels?: number\r\n  maxDecibels?: number\r\n}\r\n\r\ninterface MultiBandVolumeOptions {\r\n  bands?: number\r\n  loPass?: number\r\n  hiPass?: number\r\n  updateInterval?: number\r\n  analyserOptions?: AudioAnalyserOptions\r\n}\r\n\r\ninterface Props {\r\n  state?: AgentState\r\n  barCount?: number\r\n  mediaStream?: MediaStream | null\r\n  minHeight?: number\r\n  maxHeight?: number\r\n  demo?: boolean\r\n  centerAlign?: boolean\r\n  class?: string\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  barCount: 15,\r\n  minHeight: 20,\r\n  maxHeight: 100,\r\n  demo: false,\r\n  centerAlign: false\r\n})\r\n\r\n// --- Audio Logic ---\r\n\r\nfunction createAudioAnalyser(stream: MediaStream, options: AudioAnalyserOptions = {}) {\r\n  // Ensure this only runs in the browser\r\n  if (typeof window === 'undefined') return { analyser: null, cleanup: () => {} }\r\n\r\n  const AudioContext = window.AudioContext || (window as any).webkitAudioContext\r\n  const audioContext = new AudioContext()\r\n  const source = audioContext.createMediaStreamSource(stream)\r\n  const analyser = audioContext.createAnalyser()\r\n\r\n  if (options.fftSize) analyser.fftSize = options.fftSize\r\n  if (options.smoothingTimeConstant !== undefined) analyser.smoothingTimeConstant = options.smoothingTimeConstant\r\n  if (options.minDecibels !== undefined) analyser.minDecibels = options.minDecibels\r\n  if (options.maxDecibels !== undefined) analyser.maxDecibels = options.maxDecibels\r\n\r\n  source.connect(analyser)\r\n\r\n  return {\r\n    analyser,\r\n    cleanup: () => {\r\n      source.disconnect()\r\n      if (audioContext.state !== 'closed') audioContext.close()\r\n    }\r\n  }\r\n}\r\n\r\nconst normalizeDb = (value: number) => {\r\n  if (value === -Infinity) return 0\r\n  const minDb = -100\r\n  const maxDb = -10\r\n  const db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100\r\n  return Math.sqrt(db)\r\n}\r\n\r\nfunction useMultibandVolume(\r\n    streamRef: Ref<MediaStream | null | undefined>,\r\n    options: MultiBandVolumeOptions = {}\r\n) {\r\n  const bands = options.bands ?? 5\r\n  const loPass = options.loPass ?? 100\r\n  const hiPass = options.hiPass ?? 600\r\n  const updateInterval = options.updateInterval ?? 32\r\n  const analyserOpts = options.analyserOptions ?? { fftSize: 2048 }\r\n\r\n  const frequencyBands = ref<number[]>(new Array(bands).fill(0))\r\n  let frameId: number | undefined\r\n  let cleanupFn: (() => void) | null = null\r\n\r\n  const stop = () => {\r\n    if (typeof window !== 'undefined' && frameId) cancelAnimationFrame(frameId)\r\n    if (cleanupFn) cleanupFn()\r\n    cleanupFn = null\r\n  }\r\n\r\n  watch(streamRef, (stream) => {\r\n    // SSR Guard\r\n    if (typeof window === 'undefined') return\r\n\r\n    stop()\r\n    if (!stream) {\r\n      frequencyBands.value = new Array(bands).fill(0)\r\n      return\r\n    }\r\n\r\n    const { analyser, cleanup } = createAudioAnalyser(stream, analyserOpts)\r\n    if (!analyser) return // Should not happen due to SSR guard above, but safe to check\r\n\r\n    cleanupFn = cleanup\r\n\r\n    const bufferLength = analyser.frequencyBinCount\r\n    const dataArray = new Float32Array(bufferLength)\r\n    const sliceStart = loPass\r\n    const sliceEnd = hiPass\r\n    const sliceLength = sliceEnd - sliceStart\r\n    const chunkSize = Math.ceil(sliceLength / bands)\r\n\r\n    let lastUpdate = 0\r\n\r\n    const update = (timestamp: number) => {\r\n      if (timestamp - lastUpdate >= updateInterval) {\r\n        analyser.getFloatFrequencyData(dataArray)\r\n        const chunks = new Array(bands)\r\n\r\n        for (let i = 0; i < bands; i++) {\r\n          let sum = 0\r\n          let count = 0\r\n          const startIdx = sliceStart + i * chunkSize\r\n          const endIdx = Math.min(sliceStart + (i + 1) * chunkSize, sliceEnd)\r\n\r\n          for (let j = startIdx; j < endIdx; j++) {\r\n            sum += normalizeDb(dataArray[j])\r\n            count++\r\n          }\r\n          chunks[i] = count > 0 ? sum / count : 0\r\n        }\r\n\r\n        // Check change threshold (simple optimization)\r\n        let hasChanged = false\r\n        for(let i=0; i<bands; i++) {\r\n          if (Math.abs(chunks[i] - frequencyBands.value[i]) > 0.01) {\r\n            hasChanged = true\r\n            break\r\n          }\r\n        }\r\n\r\n        if (hasChanged) frequencyBands.value = chunks\r\n        lastUpdate = timestamp\r\n      }\r\n      frameId = requestAnimationFrame(update)\r\n    }\r\n    frameId = requestAnimationFrame(update)\r\n  }, { immediate: true })\r\n\r\n  onUnmounted(stop)\r\n\r\n  return frequencyBands\r\n}\r\n\r\n// --- Animation Logic ---\r\n\r\nconst generateConnectingSequenceBar = (columns: number) => {\r\n  const seq = []\r\n  for (let x = 0; x < columns; x++) {\r\n    seq.push([x, columns - 1 - x])\r\n  }\r\n  return seq\r\n}\r\n\r\nconst generateListeningSequenceBar = (columns: number) => {\r\n  const center = Math.floor(columns / 2)\r\n  return [[center], [-1]]\r\n}\r\n\r\nfunction useBarAnimator(stateRef: Ref<AgentState | undefined>, columnsRef: Ref<number>, intervalRef: Ref<number>) {\r\n  const currentFrame = ref<number[]>([])\r\n  let frameId: number | undefined\r\n  let startTime = 0\r\n  let index = 0\r\n\r\n  const sequence = computed(() => {\r\n    const state = stateRef.value\r\n    const cols = columnsRef.value\r\n    if (state === 'thinking' || state === 'listening') return generateListeningSequenceBar(cols)\r\n    if (state === 'connecting' || state === 'initializing') return generateConnectingSequenceBar(cols)\r\n    if (state === undefined || state === 'speaking') return [Array.from({ length: cols }, (_, i) => i)]\r\n    return [[]]\r\n  })\r\n\r\n  const animate = (time: number) => {\r\n    const interval = intervalRef.value\r\n    if (time - startTime >= interval) {\r\n      index = (index + 1) % sequence.value.length\r\n      currentFrame.value = sequence.value[index] || []\r\n      startTime = time\r\n    }\r\n    frameId = requestAnimationFrame(animate)\r\n  }\r\n\r\n  watch([stateRef, columnsRef], () => {\r\n    index = 0\r\n    currentFrame.value = sequence.value[0] || []\r\n  })\r\n\r\n  onMounted(() => {\r\n    startTime = performance.now()\r\n    frameId = requestAnimationFrame(animate)\r\n  })\r\n\r\n  onUnmounted(() => {\r\n    if (frameId) cancelAnimationFrame(frameId)\r\n  })\r\n\r\n  return currentFrame\r\n}\r\n\r\n// --- Main Logic ---\r\n\r\n// Real Volume\r\nconst mediaStreamRef = computed(() => props.mediaStream)\r\nconst realVolumeBands = useMultibandVolume(mediaStreamRef, {\r\n  bands: props.barCount,\r\n  loPass: 100,\r\n  hiPass: 200\r\n})\r\n\r\n// Fake Volume (Demo)\r\nconst fakeVolumeBands = ref<number[]>(new Array(props.barCount).fill(0.2))\r\nlet fakeAnimId: number | undefined\r\n\r\nconst startFakeAnimation = () => {\r\n  if (typeof window === 'undefined') return // SSR Check\r\n\r\n  let lastUpdate = 0\r\n  const updateInterval = 50\r\n  const startTime = Date.now() / 1000\r\n\r\n  const update = (timestamp: number) => {\r\n    if (timestamp - lastUpdate >= updateInterval) {\r\n      const time = Date.now() / 1000 - startTime\r\n      const newBands = new Array(props.barCount)\r\n      for (let i = 0; i < props.barCount; i++) {\r\n        const waveOffset = i * 0.5\r\n        const baseVolume = Math.sin(time * 2 + waveOffset) * 0.3 + 0.5\r\n        const randomNoise = Math.random() * 0.2\r\n        newBands[i] = Math.max(0.1, Math.min(1, baseVolume + randomNoise))\r\n      }\r\n      fakeVolumeBands.value = newBands\r\n      lastUpdate = timestamp\r\n    }\r\n    fakeAnimId = requestAnimationFrame(update)\r\n  }\r\n  fakeAnimId = requestAnimationFrame(update)\r\n}\r\n\r\nwatch(() => [props.demo, props.state, props.barCount], () => {\r\n  // SSR Guard for Watcher with immediate: true\r\n  if (typeof window === 'undefined') return\r\n\r\n  if (fakeAnimId) cancelAnimationFrame(fakeAnimId)\r\n\r\n  if (props.demo && (props.state === 'speaking' || props.state === 'listening')) {\r\n    startFakeAnimation()\r\n  } else {\r\n    fakeVolumeBands.value = new Array(props.barCount).fill(0.2)\r\n  }\r\n}, { immediate: true })\r\n\r\nonUnmounted(() => {\r\n  if (typeof window !== 'undefined' && fakeAnimId) cancelAnimationFrame(fakeAnimId)\r\n})\r\n\r\nconst volumeBands = computed(() => props.demo ? fakeVolumeBands.value : realVolumeBands.value)\r\n\r\n// Animator\r\nconst stateRef = computed(() => props.state)\r\nconst barCountRef = computed(() => props.barCount)\r\nconst intervalRef = computed(() => {\r\n  if (props.state === 'connecting') return 2000 / props.barCount\r\n  if (props.state === 'thinking') return 150\r\n  if (props.state === 'listening') return 500\r\n  return 1000\r\n})\r\n\r\nconst highlightedIndices = useBarAnimator(stateRef, barCountRef, intervalRef)\r\n\r\n</script>\r\n\r\n<template>\r\n  <div\r\n      :class=\"cn(\r\n      'relative flex justify-center gap-1.5',\r\n      centerAlign ? 'items-center' : 'items-end',\r\n      'bg-muted h-32 w-full overflow-hidden rounded-lg p-4',\r\n      props.class\r\n    )\"\r\n      :data-state=\"state\"\r\n  >\r\n    <div\r\n        v-for=\"(volume, index) in volumeBands\"\r\n        :key=\"index\"\r\n        :data-highlighted=\"highlightedIndices.includes(index)\"\r\n        :class=\"cn(\r\n        'max-w-[12px] min-w-[8px] flex-1 transition-all duration-150 rounded-full',\r\n        'bg-border data-[highlighted=true]:bg-primary',\r\n        state === 'speaking' && 'bg-primary',\r\n        state === 'thinking' && highlightedIndices.includes(index) && 'animate-pulse'\r\n      )\"\r\n        :style=\"{\r\n        height: `${Math.min(maxHeight, Math.max(minHeight, volume * 100 + 5))}%`,\r\n        animationDuration: state === 'thinking' ? '300ms' : undefined\r\n      }\"\r\n    ></div>\r\n  </div>\r\n</template>\r\n}",
      "type": "registry:ui"
    },
    {
      "path": "bar-visualizer/index.ts",
      "content": "export { default as BarVisualizer } from './BarVisualizer.vue'\nexport type { AgentState } from './BarVisualizer.vue'\n",
      "type": "registry:ui"
    }
  ]
}