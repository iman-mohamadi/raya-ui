{
  "name": "wheel-picker",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core"
  ],
  "files": [
    {
      "path": "wheel-picker/WheelPicker.vue",
      "content": "{\r\ntype: uploaded file\r\nfileName: iman-mohamadi/enzoui/EnzOUi-481682bc4f3f825c0131815bd4179e5da136063e/app/components/ui/wheel-picker/WheelPicker.vue\r\nfullContent:\r\n<script setup lang=\"ts\">\r\nimport { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue';\r\n\r\n// --- Types ---\r\nexport type WheelPickerValue = string | number;\r\n\r\nexport interface WheelPickerOption<T extends WheelPickerValue = string | number> {\r\n  value: T;\r\n  label: string | number;\r\n}\r\n\r\nexport interface WheelPickerClassNames {\r\n  optionItem?: string;\r\n  highlightWrapper?: string;\r\n  highlightItem?: string;\r\n}\r\n\r\ninterface Props {\r\n  modelValue?: WheelPickerValue; // v-model\r\n  defaultValue?: WheelPickerValue;\r\n  options: WheelPickerOption[];\r\n  infinite?: boolean;\r\n  visibleCount?: number;\r\n  dragSensitivity?: number;\r\n  scrollSensitivity?: number;\r\n  optionItemHeight?: number;\r\n  classNames?: WheelPickerClassNames;\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  infinite: false,\r\n  visibleCount: 20,\r\n  dragSensitivity: 3,\r\n  scrollSensitivity: 5,\r\n  optionItemHeight: 30,\r\n  options: () => [],\r\n});\r\n\r\nconst emit = defineEmits<{\r\n  (e: 'update:modelValue', value: WheelPickerValue): void;\r\n  (e: 'change', value: WheelPickerValue): void;\r\n}>();\r\n\r\n// --- Constants ---\r\nconst RESISTANCE = 0.3;\r\nconst MAX_VELOCITY = 30;\r\n\r\nconst easeOutCubic = (p: number) => Math.pow(p - 1, 3) + 1;\r\nconst clamp = (value: number, min: number, max: number) => Math.max(min, Math.min(value, max));\r\n\r\n// --- State & Refs ---\r\nconst containerRef = ref<HTMLElement | null>(null);\r\nconst wheelItemsRef = ref<HTMLElement | null>(null);\r\nconst highlightListRef = ref<HTMLElement | null>(null);\r\n\r\nconst internalValue = ref<WheelPickerValue>(\r\n    props.modelValue ?? props.defaultValue ?? props.options[0]?.value\r\n);\r\n\r\nconst scrollPos = ref(0);\r\nconst moveId = ref(0);\r\nconst isDragging = ref(false);\r\nconst lastWheelTime = ref(0);\r\n\r\nconst touchData = {\r\n  startY: 0,\r\n  yList: [] as [number, number][],\r\n  touchScroll: 0,\r\n  isClick: true,\r\n};\r\n\r\nlet dragController: AbortController | null = null;\r\n\r\n// --- Computed Layouts ---\r\nconst itemHeight = computed(() => props.optionItemHeight);\r\nconst halfItemHeight = computed(() => itemHeight.value * 0.5);\r\nconst safeVisibleCount = computed(() => Math.max(4, props.visibleCount));\r\nconst itemAngle = computed(() => 360 / safeVisibleCount.value);\r\nconst radius = computed(() => itemHeight.value / Math.tan((itemAngle.value * Math.PI) / 180));\r\nconst containerHeight = computed(() => Math.round(radius.value * 2 + itemHeight.value * 0.25));\r\nconst quarterCount = computed(() => safeVisibleCount.value >> 2);\r\nconst baseDeceleration = computed(() => props.dragSensitivity * 10);\r\nconst snapBackDeceleration = 10;\r\n\r\nconst displayOptions = computed(() => {\r\n  if (!props.infinite) return props.options;\r\n\r\n  const result: WheelPickerOption[] = [];\r\n  const halfCount = Math.ceil(safeVisibleCount.value / 2);\r\n\r\n  if (props.options.length === 0) return result;\r\n\r\n  let tempOptions = [...props.options];\r\n  while (result.length < halfCount) {\r\n    result.push(...tempOptions);\r\n  }\r\n  return result;\r\n});\r\n\r\nconst renderItems = computed(() => {\r\n  const items: Array<{\r\n    option: WheelPickerOption;\r\n    index: number;\r\n    angle: number;\r\n    key: string | number;\r\n    style: any\r\n  }> = [];\r\n\r\n  const getStyle = (angle: number) => ({\r\n    top: `${-halfItemHeight.value}px`,\r\n    height: `${itemHeight.value}px`,\r\n    lineHeight: `${itemHeight.value}px`,\r\n    transform: `rotateX(${angle}deg) translateZ(${radius.value}px)`,\r\n    // IMPORTANT: visibility is handled by JS updateStyles\r\n  });\r\n\r\n  displayOptions.value.forEach((option, index) => {\r\n    items.push({\r\n      option,\r\n      index,\r\n      angle: -itemAngle.value * index,\r\n      key: index,\r\n      style: getStyle(-itemAngle.value * index)\r\n    });\r\n  });\r\n\r\n  if (props.infinite) {\r\n    for (let i = 0; i < quarterCount.value; ++i) {\r\n      const prependIndex = -i - 1;\r\n      const appendIndex = i + displayOptions.value.length;\r\n\r\n      const preOption = displayOptions.value[displayOptions.value.length - i - 1];\r\n      items.unshift({\r\n        option: preOption,\r\n        index: prependIndex,\r\n        angle: itemAngle.value * (i + 1),\r\n        key: `pre-${i}`,\r\n        style: getStyle(itemAngle.value * (i + 1))\r\n      });\r\n\r\n      const postOption = displayOptions.value[i];\r\n      items.push({\r\n        option: postOption,\r\n        index: appendIndex,\r\n        angle: -itemAngle.value * appendIndex,\r\n        key: `post-${i}`,\r\n        style: getStyle(-itemAngle.value * appendIndex)\r\n      });\r\n    }\r\n  }\r\n\r\n  return items;\r\n});\r\n\r\nconst renderHighlightItems = computed(() => {\r\n  const items = displayOptions.value.map((option, index) => ({\r\n    option,\r\n    key: index\r\n  }));\r\n\r\n  if (props.infinite && displayOptions.value.length > 0) {\r\n    const firstItem = displayOptions.value[0];\r\n    const lastItem = displayOptions.value[displayOptions.value.length - 1];\r\n    items.unshift({ option: lastItem, key: 'infinite-start' });\r\n    items.push({ option: firstItem, key: 'infinite-end' });\r\n  }\r\n\r\n  return items;\r\n});\r\n\r\nconst wheelSegmentPositions = computed(() => {\r\n  let positionAlongWheel = 0;\r\n  const degToRad = Math.PI / 180;\r\n  const segmentRanges: [number, number][] = [];\r\n\r\n  for (let i = quarterCount.value - 1; i >= -quarterCount.value + 1; --i) {\r\n    const angle = i * itemAngle.value;\r\n    const segmentLength = itemHeight.value * Math.cos(angle * degToRad);\r\n    const start = positionAlongWheel;\r\n    positionAlongWheel += segmentLength;\r\n    segmentRanges.push([start, positionAlongWheel]);\r\n  }\r\n  return segmentRanges;\r\n});\r\n\r\n// --- Core Logic ---\r\n\r\nconst normalizeScroll = (scroll: number) => {\r\n  const length = displayOptions.value.length;\r\n  if (length === 0) return 0;\r\n  return ((scroll % length) + length) % length;\r\n};\r\n\r\nconst updateStyles = (scroll: number) => {\r\n  const normalizedScroll = props.infinite ? normalizeScroll(scroll) : scroll;\r\n\r\n  if (wheelItemsRef.value) {\r\n    const transform = `translateZ(${-radius.value}px) rotateX(${itemAngle.value * normalizedScroll}deg)`;\r\n    wheelItemsRef.value.style.transform = transform;\r\n\r\n    const children = wheelItemsRef.value.children;\r\n    for (let i = 0; i < children.length; i++) {\r\n      const li = children[i] as HTMLElement;\r\n      const indexStr = li.dataset.index;\r\n      if (indexStr !== undefined) {\r\n        const index = parseFloat(indexStr);\r\n        const distance = Math.abs(index - normalizedScroll);\r\n\r\n        // 1. Visibility Culling: Hide items far away for performance\r\n        const isVisible = distance <= quarterCount.value;\r\n        li.style.visibility = isVisible ? \"visible\" : \"hidden\";\r\n\r\n        // 2. Ghosting Fix:\r\n        // If the item is very close to the center (distance < 0.3),\r\n        // we hide the 3D version so it doesn't overlap with the Highlight version.\r\n        // We use opacity for a smoother transition than visibility.\r\n        if (isVisible) {\r\n          if (distance < 0.3) {\r\n            li.style.opacity = \"0\"; // Hide 3D item, show only Highlight item\r\n          } else {\r\n            li.style.opacity = \"1\"; // Show 3D item\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (highlightListRef.value) {\r\n    highlightListRef.value.style.transform = `translateY(${-normalizedScroll * itemHeight.value}px)`;\r\n  }\r\n\r\n  return normalizedScroll;\r\n};\r\n\r\nconst scrollTo = (scroll: number) => {\r\n  return updateStyles(scroll);\r\n};\r\n\r\nconst cancelAnimation = () => {\r\n  cancelAnimationFrame(moveId.value);\r\n};\r\n\r\nconst animateScroll = (\r\n    startScroll: number,\r\n    endScroll: number,\r\n    duration: number,\r\n    onComplete?: () => void\r\n) => {\r\n  if (startScroll === endScroll || duration === 0) {\r\n    scrollTo(startScroll);\r\n    return;\r\n  }\r\n\r\n  const startTime = performance.now();\r\n  const totalDistance = endScroll - startScroll;\r\n\r\n  const tick = (currentTime: number) => {\r\n    const elapsed = (currentTime - startTime) / 1000;\r\n\r\n    if (elapsed < duration) {\r\n      const progress = easeOutCubic(elapsed / duration);\r\n      scrollPos.value = scrollTo(startScroll + progress * totalDistance);\r\n      moveId.value = requestAnimationFrame(tick);\r\n    } else {\r\n      cancelAnimation();\r\n      scrollPos.value = scrollTo(endScroll);\r\n      onComplete?.();\r\n    }\r\n  };\r\n\r\n  moveId.value = requestAnimationFrame(tick);\r\n};\r\n\r\nconst selectByScroll = (scroll: number) => {\r\n  const normalized = normalizeScroll(scroll) | 0;\r\n  const length = displayOptions.value.length;\r\n  if (!length) return;\r\n\r\n  const boundedScroll = props.infinite\r\n      ? normalized\r\n      : Math.min(Math.max(normalized, 0), length - 1);\r\n\r\n  if (!props.infinite && boundedScroll !== scroll) return;\r\n\r\n  scrollPos.value = scrollTo(boundedScroll);\r\n\r\n  const selectedOption = displayOptions.value[scrollPos.value];\r\n  if (selectedOption) {\r\n    internalValue.value = selectedOption.value;\r\n    emit('update:modelValue', selectedOption.value);\r\n    emit('change', selectedOption.value);\r\n  }\r\n};\r\n\r\nconst selectByValue = (val: WheelPickerValue) => {\r\n  const index = displayOptions.value.findIndex((opt) => opt.value === val);\r\n  if (index === -1) {\r\n    if (displayOptions.value.length > 0) {\r\n      scrollPos.value = scrollTo(0);\r\n    }\r\n    return;\r\n  }\r\n  cancelAnimation();\r\n  scrollPos.value = scrollTo(index);\r\n};\r\n\r\nconst scrollByStep = (step: number) => {\r\n  const startScroll = scrollPos.value;\r\n  let endScroll = startScroll + step;\r\n\r\n  if (props.infinite) {\r\n    endScroll = Math.round(endScroll);\r\n  } else {\r\n    endScroll = clamp(Math.round(endScroll), 0, displayOptions.value.length - 1);\r\n  }\r\n\r\n  const distance = Math.abs(endScroll - startScroll);\r\n  if (distance === 0) return;\r\n\r\n  const duration = Math.sqrt(distance / props.scrollSensitivity);\r\n\r\n  cancelAnimation();\r\n  animateScroll(startScroll, endScroll, duration, () => {\r\n    selectByScroll(scrollPos.value);\r\n  });\r\n};\r\n\r\n// --- Input Handlers ---\r\n\r\nconst handleWheelItemClick = (clientY: number) => {\r\n  const container = containerRef.value;\r\n  if (!container) return;\r\n\r\n  const { top } = container.getBoundingClientRect();\r\n  const clickOffsetY = clientY - top;\r\n\r\n  const clickedSegmentIndex = wheelSegmentPositions.value.findIndex(\r\n      ([start, end]) => clickOffsetY >= start && clickOffsetY <= end\r\n  );\r\n\r\n  if (clickedSegmentIndex === -1) return;\r\n\r\n  const stepsToScroll = (quarterCount.value - clickedSegmentIndex - 1) * -1;\r\n  scrollByStep(stepsToScroll);\r\n};\r\n\r\nconst updateScrollDuringDrag = (e: MouseEvent | TouchEvent) => {\r\n  const currentY = (window.TouchEvent && e instanceof TouchEvent ? e.touches?.[0]?.clientY : (e as MouseEvent).clientY) || 0;\r\n\r\n  if (touchData.isClick) {\r\n    const dragThreshold = 5;\r\n    if (Math.abs(currentY - touchData.startY) > dragThreshold) {\r\n      touchData.isClick = false;\r\n    }\r\n  }\r\n\r\n  touchData.yList.push([currentY, Date.now()]);\r\n  if (touchData.yList.length > 5) touchData.yList.shift();\r\n\r\n  const dragDelta = (touchData.startY - currentY) / itemHeight.value;\r\n  let nextScroll = scrollPos.value + dragDelta;\r\n\r\n  if (props.infinite) {\r\n    nextScroll = normalizeScroll(nextScroll);\r\n  } else {\r\n    const maxIndex = displayOptions.value.length;\r\n    if (nextScroll < 0) nextScroll *= RESISTANCE;\r\n    else if (nextScroll > maxIndex) nextScroll = maxIndex + (nextScroll - maxIndex) * RESISTANCE;\r\n  }\r\n\r\n  touchData.touchScroll = updateStyles(nextScroll);\r\n};\r\n\r\nconst handleDragMoveEvent = (event: Event) => {\r\n  const e = event as MouseEvent | TouchEvent;\r\n  if (!isDragging.value && !containerRef.value?.contains(e.target as Node) && e.target !== containerRef.value) {\r\n    return;\r\n  }\r\n  if (e.cancelable) e.preventDefault();\r\n  if (displayOptions.value.length) updateScrollDuringDrag(e);\r\n};\r\n\r\nconst initiateDragGesture = (event: MouseEvent | TouchEvent) => {\r\n  isDragging.value = true;\r\n  dragController = new AbortController();\r\n  const { signal } = dragController;\r\n  const passiveOpts = { signal, passive: false } as AddEventListenerOptions;\r\n\r\n  containerRef.value?.addEventListener('touchmove', handleDragMoveEvent, passiveOpts);\r\n  document.addEventListener('mousemove', handleDragMoveEvent, passiveOpts);\r\n\r\n  const startY = (window.TouchEvent && event instanceof TouchEvent ? event.touches?.[0]?.clientY : (event as MouseEvent).clientY) || 0;\r\n\r\n  touchData.startY = startY;\r\n  touchData.yList = [[startY, Date.now()]];\r\n  touchData.touchScroll = scrollPos.value;\r\n  touchData.isClick = true;\r\n\r\n  cancelAnimation();\r\n};\r\n\r\nconst decelerateAndAnimateScroll = (initialVelocity: number) => {\r\n  scrollPos.value = touchData.touchScroll;\r\n\r\n  const currentScroll = scrollPos.value;\r\n  let targetScroll = currentScroll;\r\n  let deceleration = initialVelocity > 0 ? -baseDeceleration.value : baseDeceleration.value;\r\n  let duration = 0;\r\n\r\n  if (props.infinite) {\r\n    duration = Math.abs(initialVelocity / deceleration);\r\n    const scrollDistance = initialVelocity * duration + 0.5 * deceleration * duration * duration;\r\n    targetScroll = Math.round(currentScroll + scrollDistance);\r\n  } else if (currentScroll < 0 || currentScroll > displayOptions.value.length - 1) {\r\n    const target = clamp(currentScroll, 0, displayOptions.value.length - 1);\r\n    const scrollDistance = currentScroll - target;\r\n    deceleration = snapBackDeceleration;\r\n    duration = Math.sqrt(Math.abs(scrollDistance / deceleration));\r\n    initialVelocity = deceleration * duration;\r\n    initialVelocity = currentScroll > 0 ? -initialVelocity : initialVelocity;\r\n    targetScroll = target;\r\n  } else {\r\n    duration = Math.abs(initialVelocity / deceleration);\r\n    const scrollDistance = initialVelocity * duration + 0.5 * deceleration * duration * duration;\r\n    targetScroll = Math.round(currentScroll + scrollDistance);\r\n    targetScroll = clamp(targetScroll, 0, displayOptions.value.length - 1);\r\n\r\n    const adjustedDistance = targetScroll - currentScroll;\r\n    duration = Math.sqrt(Math.abs(adjustedDistance / deceleration));\r\n  }\r\n\r\n  animateScroll(currentScroll, targetScroll, duration, () => {\r\n    selectByScroll(scrollPos.value);\r\n  });\r\n\r\n  // Fallback sync\r\n  selectByScroll(scrollPos.value);\r\n};\r\n\r\nconst finalizeDragAndStartInertiaScroll = () => {\r\n  dragController?.abort();\r\n  dragController = null;\r\n  isDragging.value = false;\r\n\r\n  if (touchData.isClick) {\r\n    handleWheelItemClick(touchData.startY);\r\n    return;\r\n  }\r\n\r\n  const yList = touchData.yList;\r\n  let velocity = 0;\r\n\r\n  if (yList.length > 1) {\r\n    const [startY, startTime] = yList[yList.length - 2] || [0, 0];\r\n    const [endY, endTime] = yList[yList.length - 1] || [0, 0];\r\n    const timeDiff = endTime - startTime;\r\n    if (timeDiff > 0) {\r\n      const distance = startY - endY;\r\n      const velocityPerSecond = ((distance / itemHeight.value) * 1000) / timeDiff;\r\n      const direction = velocityPerSecond > 0 ? 1 : -1;\r\n      velocity = Math.min(Math.abs(velocityPerSecond), MAX_VELOCITY) * direction;\r\n    }\r\n  }\r\n\r\n  decelerateAndAnimateScroll(velocity);\r\n};\r\n\r\nconst handleDragStartEvent = (event: Event) => {\r\n  const e = event as MouseEvent | TouchEvent;\r\n  const isTargetValid = !!containerRef.value?.contains(e.target as Node) || e.target === containerRef.value;\r\n\r\n  if ((isDragging.value || isTargetValid) && e.cancelable) {\r\n    e.preventDefault();\r\n    if (displayOptions.value.length) initiateDragGesture(e);\r\n  }\r\n};\r\n\r\nconst handleDragEndEvent = (event: Event) => {\r\n  const e = event as MouseEvent | TouchEvent;\r\n  if (!displayOptions.value.length) return;\r\n\r\n  const isTargetValid = !!containerRef.value?.contains(e.target as Node) || e.target === containerRef.value;\r\n\r\n  if ((isDragging.value || isTargetValid) && e.cancelable) {\r\n    e.preventDefault();\r\n    finalizeDragAndStartInertiaScroll();\r\n  }\r\n};\r\n\r\nconst handleWheelEvent = (event: Event) => {\r\n  const e = event as WheelEvent;\r\n  if (!displayOptions.value.length || !containerRef.value) return;\r\n\r\n  const isTargetValid = containerRef.value.contains(e.target as Node) || e.target === containerRef.value;\r\n  if ((isDragging.value || isTargetValid) && e.cancelable) {\r\n    e.preventDefault();\r\n\r\n    const now = Date.now();\r\n    if (now - lastWheelTime.value < 100) return;\r\n\r\n    const direction = Math.sign(e.deltaY);\r\n    if (!direction) return;\r\n\r\n    lastWheelTime.value = now;\r\n    scrollByStep(direction);\r\n  }\r\n};\r\n\r\n// --- Lifecycle & Watchers ---\r\n\r\nwatch(() => props.modelValue, (newVal) => {\r\n  if (newVal !== undefined && newVal !== internalValue.value) {\r\n    internalValue.value = newVal;\r\n    selectByValue(newVal);\r\n  }\r\n});\r\n\r\nwatch(() => props.options, () => {\r\n  nextTick(() => {\r\n    selectByValue(internalValue.value);\r\n  });\r\n}, { deep: true });\r\n\r\nonMounted(() => {\r\n  const container = containerRef.value;\r\n  if (!container) return;\r\n\r\n  const opts = { passive: false };\r\n  container.addEventListener(\"touchstart\", handleDragStartEvent, opts);\r\n  container.addEventListener(\"touchend\", handleDragEndEvent, opts);\r\n  container.addEventListener(\"wheel\", handleWheelEvent, opts);\r\n  document.addEventListener(\"mousedown\", handleDragStartEvent, opts);\r\n  document.addEventListener(\"mouseup\", handleDragEndEvent, opts);\r\n\r\n  // Initial selection\r\n  nextTick(() => {\r\n    selectByValue(internalValue.value);\r\n  });\r\n});\r\n\r\nonUnmounted(() => {\r\n  const container = containerRef.value;\r\n  if (container) {\r\n    container.removeEventListener(\"touchstart\", handleDragStartEvent);\r\n    container.removeEventListener(\"touchend\", handleDragEndEvent);\r\n    container.removeEventListener(\"wheel\", handleWheelEvent);\r\n  }\r\n  document.removeEventListener(\"mousedown\", handleDragStartEvent);\r\n  document.removeEventListener(\"mouseup\", handleDragEndEvent);\r\n  dragController?.abort();\r\n  cancelAnimation();\r\n});\r\n</script>\r\n\r\n<template>\r\n  <div\r\n      ref=\"containerRef\"\r\n      class=\"rwp-wrapper\"\r\n      :class=\"classNames?.highlightWrapper\"\r\n      :style=\"{ height: `${containerHeight}px` }\"\r\n      tabindex=\"0\"\r\n      role=\"listbox\"\r\n      :aria-label=\"'Choose an option'\"\r\n  >\r\n    <ul ref=\"wheelItemsRef\" class=\"rwp-options\">\r\n      <li\r\n          v-for=\"item in renderItems\"\r\n          :key=\"item.key\"\r\n          :data-index=\"item.index\"\r\n          class=\"rwp-option-item text-muted-foreground\"\r\n          :class=\"classNames?.optionItem\"\r\n          :style=\"item.style\"\r\n      >\r\n        {{ item.option.label }}\r\n      </li>\r\n    </ul>\r\n\r\n    <div\r\n        class=\"rwp-highlight-wrapper\"\r\n        :style=\"{ height: `${itemHeight}px`, lineHeight: `${itemHeight}px` }\"\r\n    >\r\n      <ul\r\n          ref=\"highlightListRef\"\r\n          class=\"rwp-highlight-list\"\r\n          :style=\"{ top: infinite ? `${-itemHeight}px` : undefined }\"\r\n      >\r\n        <li\r\n            v-for=\"item in renderHighlightItems\"\r\n            :key=\"item.key\"\r\n            class=\"rwp-highlight-item text-foreground\"\r\n            :class=\"classNames?.highlightItem\"\r\n            :style=\"{ height: `${itemHeight}px` }\"\r\n        >\r\n          {{ item.option.label }}\r\n        </li>\r\n      </ul>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n/* Reset & Base */\r\nul {\r\n  margin: 0;\r\n  padding: 0;\r\n  list-style: none;\r\n}\r\n\r\nli {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n\r\n.rwp-wrapper {\r\n  position: relative;\r\n  overflow: hidden;\r\n  display: flex;\r\n  width: 100%;\r\n  align-items: stretch;\r\n  justify-content: space-between;\r\n  perspective: 2000px;\r\n  user-select: none;\r\n  /* Mask Image for fade effect - keeps 3D look */\r\n  mask-image: linear-gradient(\r\n      to bottom,\r\n      transparent 0%,\r\n      black 20%,\r\n      black 80%,\r\n      transparent 100%\r\n  );\r\n  -webkit-mask-image: linear-gradient(\r\n      to bottom,\r\n      transparent 0%,\r\n      black 20%,\r\n      black 80%,\r\n      transparent 100%\r\n  );\r\n  cursor: grab;\r\n}\r\n\r\n.rwp-wrapper:active {\r\n  cursor: grabbing;\r\n}\r\n\r\n/* Center Highlight Bar */\r\n.rwp-highlight-wrapper {\r\n  position: absolute;\r\n  overflow: hidden;\r\n  top: 50%;\r\n  width: 100%;\r\n  transform: translateY(-50%);\r\n  font-size: 1rem;\r\n  font-weight: 500;\r\n  pointer-events: none;\r\n  /* Use theme border color */\r\n  border-top: 1px solid var(--border);\r\n  border-bottom: 1px solid var(--border);\r\n}\r\n\r\n.rwp-highlight-list {\r\n  position: absolute;\r\n  width: 100%;\r\n  left: 0;\r\n}\r\n\r\n/* 3D Rotating List */\r\n.rwp-options {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 0;\r\n  display: block;\r\n  width: 100%;\r\n  height: 0;\r\n  margin: 0 auto;\r\n  -webkit-font-smoothing: subpixel-antialiased;\r\n  will-change: transform;\r\n  backface-visibility: hidden;\r\n  transform-style: preserve-3d;\r\n}\r\n\r\n.rwp-option-item {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  -webkit-font-smoothing: subpixel-antialiased;\r\n  will-change: visibility;\r\n  font-size: 0.875rem;\r\n  /* Use theme muted foreground for unselected items */\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  /* Transition opacity for smoother ghosting fix */\r\n  transition: opacity 0.1s linear;\r\n}\r\n\r\n.rwp-highlight-item {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  /* Adapts to parent color (Dark Mode friendly) */\r\n  color: currentColor;\r\n}\r\n</style>\r\n}",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/WheelPickerWrapper.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { cn } from '@/lib/utils';\r\n\r\ndefineProps<{\r\n  class?: string;\r\n}>();\r\n</script>\r\n\r\n<template>\r\n  <div :class=\"cn($props.class)\" data-rwp-wrapper>\r\n    <slot />\r\n  </div>\r\n</template>\r\n\r\n<style scoped>\r\n/* Exact CSS from React source */\r\n[data-rwp-wrapper] {\r\n  position: relative;\r\n  overflow: hidden;\r\n  display: flex;\r\n  width: 100%;\r\n  align-items: stretch;\r\n  justify-content: space-between;\r\n  perspective: 2000px; /* <--- THIS FIXES THE VISUAL GLITCH */\r\n  user-select: none;\r\n}\r\n\r\n:deep([data-rwp-wrapper] ul) {\r\n  margin: 0;\r\n  padding: 0;\r\n  list-style: none;\r\n}\r\n\r\n:deep([data-rwp-wrapper] li) {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n</style>",
      "type": "registry:ui"
    },
    {
      "path": "wheel-picker/index.ts",
      "content": "export { default as WheelPicker } from './WheelPicker.vue'\nexport { default as WheelPickerWrapper } from './WheelPickerWrapper.vue'\nexport type { WheelPickerOption } from './WheelPicker.vue'\n",
      "type": "registry:ui"
    }
  ]
}