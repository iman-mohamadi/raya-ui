{
  "name": "scroll-spy",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "scroll-spy/ScrollSpy.vue",
      "content": "<script setup lang=\"ts\">\r\nimport {\r\n  ref,\r\n  provide,\r\n  watch,\r\n  onMounted,\r\n  onBeforeUnmount,\r\n  computed,\r\n  type PropType\r\n} from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\nimport { useVModel } from '@vueuse/core'\r\n\r\nconst props = defineProps({\r\n  modelValue: { type: String, default: undefined },\r\n  defaultValue: { type: String, default: '' },\r\n  offset: { type: Number, default: 0 },\r\n  rootMargin: { type: String, default: undefined },\r\n  threshold: { type: [Number, Array] as PropType<number | number[]>, default: 0 },\r\n  scrollBehavior: { type: String as PropType<ScrollBehavior>, default: 'smooth' },\r\n  container: { type: Object as PropType<HTMLElement | null>, default: null },\r\n  orientation: { type: String as PropType<'horizontal' | 'vertical'>, default: 'vertical' },\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'div' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst emit = defineEmits(['update:modelValue'])\r\n\r\nconst activeId = useVModel(props, 'modelValue', emit, {\r\n  passive: true,\r\n  defaultValue: props.defaultValue,\r\n})\r\n\r\nconst sectionMap = new Map<string, HTMLElement>()\r\nconst isScrolling = ref(false)\r\nconst scrollTimeout = ref<ReturnType<typeof setTimeout> | null>(null)\r\nlet observer: IntersectionObserver | null = null\r\n\r\nconst registerSection = (id: string, element: HTMLElement) => {\r\n  sectionMap.set(id, element)\r\n  updateObserver()\r\n}\r\n\r\nconst unregisterSection = (id: string) => {\r\n  sectionMap.delete(id)\r\n  updateObserver()\r\n}\r\n\r\nconst scrollTo = (id: string) => {\r\n  const element = sectionMap.get(id) || document.getElementById(id)\r\n\r\n  if (!element) {\r\n    activeId.value = id\r\n    return\r\n  }\r\n\r\n  isScrolling.value = true\r\n  activeId.value = id\r\n\r\n  const containerEl = props.container || window\r\n  const isWindow = containerEl === window\r\n\r\n  let targetTop = 0\r\n  if (!isWindow && containerEl instanceof HTMLElement) {\r\n    const containerRect = containerEl.getBoundingClientRect()\r\n    const elementRect = element.getBoundingClientRect()\r\n    const scrollTop = containerEl.scrollTop\r\n    targetTop = elementRect.top - containerRect.top + scrollTop - props.offset\r\n\r\n    containerEl.scrollTo({\r\n      top: targetTop,\r\n      behavior: props.scrollBehavior\r\n    })\r\n  } else {\r\n    const elementRect = element.getBoundingClientRect()\r\n    const scrollTop = window.scrollY || document.documentElement.scrollTop\r\n    targetTop = elementRect.top + scrollTop - props.offset\r\n\r\n    window.scrollTo({\r\n      top: targetTop,\r\n      behavior: props.scrollBehavior\r\n    })\r\n  }\r\n\r\n  if (scrollTimeout.value) clearTimeout(scrollTimeout.value)\r\n  scrollTimeout.value = setTimeout(() => {\r\n    isScrolling.value = false\r\n  }, 1000)\r\n}\r\n\r\nconst updateObserver = () => {\r\n  if (observer) observer.disconnect()\r\n  if (sectionMap.size === 0) return\r\n\r\n  const root = props.container || null\r\n  const margin = props.rootMargin ?? `${-props.offset}px 0px -70% 0px`\r\n\r\n  observer = new IntersectionObserver((entries) => {\r\n    if (isScrolling.value) return\r\n\r\n    const intersecting = entries.filter(e => e.isIntersecting)\r\n    if (intersecting.length === 0) return\r\n\r\n    const topmost = intersecting.reduce((prev, curr) => {\r\n      return curr.boundingClientRect.top < prev.boundingClientRect.top ? curr : prev\r\n    })\r\n\r\n    const id = topmost.target.id\r\n    if (id && id !== activeId.value) {\r\n      activeId.value = id\r\n    }\r\n  }, {\r\n    root,\r\n    rootMargin: margin,\r\n    threshold: props.threshold\r\n  })\r\n\r\n  sectionMap.forEach((el) => observer?.observe(el))\r\n}\r\n\r\nwatch(() => [props.container, props.rootMargin, props.offset, props.threshold], updateObserver)\r\n\r\nonMounted(() => {\r\n  updateObserver()\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  if (observer) observer.disconnect()\r\n  if (scrollTimeout.value) clearTimeout(scrollTimeout.value)\r\n})\r\n\r\nprovide('scroll-spy', {\r\n  activeId,\r\n  scrollTo,\r\n  registerSection,\r\n  unregisterSection,\r\n  orientation: computed(() => props.orientation)\r\n})\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :class=\"cn(\r\n        'flex',\r\n        // FIX: Vertical orientation = Sidebar Mode = Row Layout (Sidebar | Content)\r\n        // Horizontal orientation = Navbar Mode = Col Layout (Navbar / Content)\r\n        orientation === 'horizontal' ? 'flex-col' : 'flex-row',\r\n        props.class\r\n      )\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpyNav.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, ref, watch, nextTick, onMounted, type ComputedRef, type Ref } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\nimport { unrefElement } from '@vueuse/core'\r\n\r\nconst props = defineProps({\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'nav' },\r\n  class: { type: String, default: '' },\r\n  indicator: { type: Boolean, default: false },\r\n  indicatorClass: { type: String, default: 'bg-primary' },\r\n  indicatorPosition: {\r\n    type: String as () => 'before' | 'after',\r\n    default: 'before'\r\n  }\r\n})\r\n\r\nconst context = inject<{\r\n  orientation: ComputedRef<'vertical' | 'horizontal'>,\r\n  activeId: Ref<string>\r\n}>('scroll-spy')\r\n\r\nif (!context) {\r\n  throw new Error('ScrollSpyNav must be used within ScrollSpy')\r\n}\r\n\r\nconst navRef = ref<InstanceType<typeof Primitive> | null>(null)\r\nconst indicatorStyle = ref({\r\n  top: 'auto',\r\n  bottom: 'auto',\r\n  left: 'auto',\r\n  right: 'auto',\r\n  height: '0px',\r\n  width: '0px',\r\n  opacity: 0\r\n})\r\n\r\nconst updateIndicator = async () => {\r\n  // FIX: Safely unwrap DOM element\r\n  const el = unrefElement(navRef)\r\n  if (!props.indicator || !el) return\r\n\r\n  await nextTick()\r\n\r\n  const currentId = context.activeId.value\r\n  // FIX: Query by ID value instead of active state to avoid race conditions\r\n  const activeLink = currentId\r\n      ? el.querySelector(`[data-scroll-spy-value=\"${currentId}\"]`) as HTMLElement\r\n      : null\r\n\r\n  if (!activeLink) {\r\n    indicatorStyle.value = { ...indicatorStyle.value, opacity: 0 }\r\n    return\r\n  }\r\n\r\n  const styles: any = { opacity: 1 }\r\n  const isHorizontal = context.orientation.value === 'horizontal'\r\n  const isAfter = props.indicatorPosition === 'after'\r\n\r\n  if (isHorizontal) {\r\n    // Horizontal Nav (Navbar)\r\n    styles.left = `${activeLink.offsetLeft}px`\r\n    styles.width = `${activeLink.offsetWidth}px`\r\n    styles.height = '2px'\r\n\r\n    if (isAfter) {\r\n      styles.bottom = '0'\r\n      styles.top = 'auto'\r\n    } else {\r\n      styles.top = '0'\r\n      styles.bottom = 'auto'\r\n    }\r\n  } else {\r\n    // Vertical Nav (Sidebar)\r\n    styles.top = `${activeLink.offsetTop}px`\r\n    styles.height = `${activeLink.offsetHeight}px`\r\n    styles.width = '2px'\r\n\r\n    if (isAfter) {\r\n      styles.right = '0'\r\n      styles.left = 'auto'\r\n    } else {\r\n      styles.left = '0'\r\n      styles.right = 'auto'\r\n    }\r\n  }\r\n\r\n  indicatorStyle.value = styles\r\n}\r\n\r\nwatch(context.activeId, updateIndicator, { immediate: true })\r\n\r\nonMounted(() => {\r\n  if (props.indicator) {\r\n    window.addEventListener('resize', updateIndicator)\r\n    setTimeout(updateIndicator, 100)\r\n  }\r\n})\r\n</script>\r\n\r\n<template>\r\n  <div class=\"relative\">\r\n    <div\r\n        v-if=\"indicator\"\r\n        :class=\"cn(\r\n        'absolute rounded-full transition-all duration-300 ease-[cubic-bezier(0.25,0.8,0.25,1)]',\r\n        props.indicatorClass\r\n      )\"\r\n        :style=\"indicatorStyle\"\r\n    />\r\n\r\n    <Primitive\r\n        ref=\"navRef\"\r\n        :as=\"as\"\r\n        :as-child=\"asChild\"\r\n        :class=\"cn(\r\n        'flex gap-2',\r\n        // FIX: Item direction logic\r\n        // Vertical Parent (Sidebar) -> Flex Col Items\r\n        // Horizontal Parent (Navbar) -> Flex Row Items\r\n        context.orientation.value === 'horizontal' ? 'flex-row' : 'flex-col',\r\n\r\n        // Padding adjustments for indicator\r\n        indicator && context.orientation.value === 'vertical' && indicatorPosition === 'before' ? 'pl-4' : '',\r\n        indicator && context.orientation.value === 'vertical' && indicatorPosition === 'after' ? 'pr-4' : '',\r\n        indicator && context.orientation.value === 'horizontal' && indicatorPosition === 'before' ? 'pt-4' : '',\r\n        indicator && context.orientation.value === 'horizontal' && indicatorPosition === 'after' ? 'pb-4' : '',\r\n        props.class\r\n      )\"\r\n    >\r\n      <slot />\r\n    </Primitive>\r\n  </div>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpyLink.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, computed, type Ref } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\n\r\ninterface Props {\r\n  value: string\r\n  as?: string\r\n  asChild?: boolean\r\n  class?: string\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  as: 'a',\r\n  asChild: false,\r\n  class: '',\r\n})\r\n\r\nconst context = inject<{\r\n  activeId: Ref<string>,\r\n  scrollTo: (id: string) => void\r\n}>('scroll-spy')\r\n\r\nif (!context) {\r\n  throw new Error('ScrollSpyLink must be used within ScrollSpy')\r\n}\r\n\r\nconst isActive = computed(() => context.activeId.value === props.value)\r\n\r\nconst handleClick = (e: MouseEvent) => {\r\n  e.preventDefault()\r\n  context.scrollTo(props.value)\r\n}\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :href=\"`#${value}`\"\r\n      :data-state=\"isActive ? 'active' : 'inactive'\"\r\n      :data-scroll-spy-value=\"value\"\r\n      @click=\"handleClick\"\r\n      :class=\"cn(\r\n      'rounded-md px-3 py-1.5 text-sm font-medium transition-colors cursor-pointer',\r\n      'text-muted-foreground hover:text-foreground hover:bg-accent/50',\r\n      'data-[state=active]:bg-accent data-[state=active]:text-foreground',\r\n      props.class\r\n    )\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpyViewport.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, type ComputedRef } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst props = defineProps({\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'div' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst context = inject<{ orientation: ComputedRef<string> }>('scroll-spy')\r\nif (!context) throw new Error('ScrollSpyViewport must be used within ScrollSpy')\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :data-orientation=\"context.orientation.value\"\r\n      :class=\"cn('flex flex-1 flex-col gap-8', props.class)\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpySection.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, ref, onMounted, onBeforeUnmount, type ComputedRef } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst props = defineProps({\r\n  value: { type: String, required: true },\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'div' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst context = inject<{\r\n  registerSection: (id: string, el: HTMLElement) => void,\r\n  unregisterSection: (id: string) => void,\r\n  orientation: ComputedRef<string>\r\n}>('scroll-spy')\r\n\r\nif (!context) throw new Error('ScrollSpySection must be used within ScrollSpy')\r\n\r\nconst elementRef = ref<HTMLElement | null>(null)\r\n\r\nonMounted(() => {\r\n  if (elementRef.value) {\r\n    // If asChild is used, Primitive renders the slot content directly,\r\n    // but the ref still points to the DOM element if configured correctly.\r\n    // However, with reka-ui Primitive, the ref usually works on the underlying element.\r\n    // If using a component as child, ensure it forwards refs.\r\n    context.registerSection(props.value, elementRef.value.$el || elementRef.value)\r\n  }\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  context.unregisterSection(props.value)\r\n})\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      ref=\"elementRef\"\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :id=\"value\"\r\n      :data-orientation=\"context.orientation.value\"\r\n      :class=\"props.class\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/index.ts",
      "content": "export { default as ScrollSpy } from './ScrollSpy.vue'\n",
      "type": "registry:ui"
    }
  ]
}