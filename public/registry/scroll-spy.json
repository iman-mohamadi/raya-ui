{
  "name": "scroll-spy",
  "type": "registry:ui",
  "dependencies": [
    "@vueuse/core",
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "scroll-spy/ScrollSpy.vue",
      "content": "<script setup lang=\"ts\">\r\nimport {\r\n  ref,\r\n  provide,\r\n  watch,\r\n  onMounted,\r\n  onBeforeUnmount,\r\n  computed,\r\n  type PropType\r\n} from 'vue'\r\nimport { Primitive, type PrimitiveProps } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\nimport { useVModel } from '@vueuse/core'\r\n\r\nconst props = defineProps({\r\n  modelValue: { type: String, default: undefined },\r\n  defaultValue: { type: String, default: '' },\r\n  offset: { type: Number, default: 0 },\r\n  rootMargin: { type: String, default: undefined },\r\n  threshold: { type: [Number, Array] as PropType<number | number[]>, default: 0 },\r\n  scrollBehavior: { type: String as PropType<ScrollBehavior>, default: 'smooth' },\r\n  container: { type: Object as PropType<HTMLElement | null>, default: null },\r\n  orientation: { type: String as PropType<'horizontal' | 'vertical'>, default: 'vertical' },\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'div' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst emit = defineEmits(['update:modelValue'])\r\n\r\nconst activeId = useVModel(props, 'modelValue', emit, {\r\n  passive: true,\r\n  defaultValue: props.defaultValue,\r\n})\r\n\r\nconst sectionMap = new Map<string, HTMLElement>()\r\nconst isScrolling = ref(false)\r\nconst scrollTimeout = ref<ReturnType<typeof setTimeout> | null>(null)\r\nlet observer: IntersectionObserver | null = null\r\n\r\n// Registration methods for children\r\nconst registerSection = (id: string, element: HTMLElement) => {\r\n  sectionMap.set(id, element)\r\n  updateObserver()\r\n}\r\n\r\nconst unregisterSection = (id: string) => {\r\n  sectionMap.delete(id)\r\n  updateObserver()\r\n}\r\n\r\n// Scroll Logic\r\nconst scrollToSection = (id: string) => {\r\n  const element = sectionMap.get(id) || document.getElementById(id)\r\n\r\n  if (!element) {\r\n    activeId.value = id\r\n    return\r\n  }\r\n\r\n  isScrolling.value = true\r\n  activeId.value = id\r\n\r\n  const containerEl = props.container || window\r\n  const isWindow = containerEl === window\r\n\r\n  // Calculate position\r\n  let targetTop = 0\r\n  if (!isWindow && containerEl instanceof HTMLElement) {\r\n    const containerRect = containerEl.getBoundingClientRect()\r\n    const elementRect = element.getBoundingClientRect()\r\n    const scrollTop = containerEl.scrollTop\r\n    targetTop = elementRect.top - containerRect.top + scrollTop - props.offset\r\n\r\n    containerEl.scrollTo({\r\n      top: targetTop,\r\n      behavior: props.scrollBehavior\r\n    })\r\n  } else {\r\n    const elementRect = element.getBoundingClientRect()\r\n    const scrollTop = window.scrollY || document.documentElement.scrollTop\r\n    targetTop = elementRect.top + scrollTop - props.offset\r\n\r\n    window.scrollTo({\r\n      top: targetTop,\r\n      behavior: props.scrollBehavior\r\n    })\r\n  }\r\n\r\n  // Timeout to re-enable observer after scroll animation\r\n  if (scrollTimeout.value) clearTimeout(scrollTimeout.value)\r\n  scrollTimeout.value = setTimeout(() => {\r\n    isScrolling.value = false\r\n  }, 1000) // generous timeout for smooth scroll\r\n}\r\n\r\n// Observer Logic\r\nconst updateObserver = () => {\r\n  if (observer) observer.disconnect()\r\n  if (sectionMap.size === 0) return\r\n\r\n  const root = props.container || null\r\n  // default margin logic from original react component\r\n  const margin = props.rootMargin ?? `${-props.offset}px 0px -70% 0px`\r\n\r\n  observer = new IntersectionObserver((entries) => {\r\n    if (isScrolling.value) return\r\n\r\n    const intersecting = entries.filter(e => e.isIntersecting)\r\n    if (intersecting.length === 0) return\r\n\r\n    // Find the topmost intersecting element\r\n    const topmost = intersecting.reduce((prev, curr) => {\r\n      return curr.boundingClientRect.top < prev.boundingClientRect.top ? curr : prev\r\n    })\r\n\r\n    const id = topmost.target.id\r\n    if (id && id !== activeId.value) {\r\n      activeId.value = id\r\n    }\r\n  }, {\r\n    root,\r\n    rootMargin: margin,\r\n    threshold: props.threshold\r\n  })\r\n\r\n  sectionMap.forEach((el) => observer?.observe(el))\r\n}\r\n\r\nwatch(() => [props.container, props.rootMargin, props.offset, props.threshold], updateObserver)\r\n\r\nonMounted(() => {\r\n  updateObserver()\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  if (observer) observer.disconnect()\r\n  if (scrollTimeout.value) clearTimeout(scrollTimeout.value)\r\n})\r\n\r\nprovide('scroll-spy', {\r\n  activeId,\r\n  scrollToSection,\r\n  registerSection,\r\n  unregisterSection,\r\n  orientation: computed(() => props.orientation)\r\n})\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :class=\"cn('flex', orientation === 'horizontal' ? 'flex-row' : 'flex-col', props.class)\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpyNav.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, type ComputedRef } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst props = defineProps({\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'nav' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst context = inject<{ orientation: ComputedRef<string> }>('scroll-spy')\r\n\r\nif (!context) {\r\n  throw new Error('ScrollSpyNav must be used within ScrollSpy')\r\n}\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :class=\"cn(\r\n      'flex gap-2',\r\n      context.orientation.value === 'horizontal' ? 'flex-col' : 'flex-row',\r\n      props.class\r\n    )\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpyLink.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, computed, type Ref, type ComputedRef } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst props = defineProps({\r\n  value: { type: String, required: true },\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'a' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst context = inject<{\r\n  activeId: Ref<string>,\r\n  scrollToSection: (id: string) => void,\r\n  orientation: ComputedRef<string>\r\n}>('scroll-spy')\r\n\r\nif (!context) {\r\n  throw new Error('ScrollSpyLink must be used within ScrollSpy')\r\n}\r\n\r\nconst isActive = computed(() => context.activeId.value === props.value)\r\n\r\nconst handleClick = (e: MouseEvent) => {\r\n  e.preventDefault()\r\n  context.scrollToSection(props.value)\r\n}\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :href=\"`#${value}`\"\r\n      :data-state=\"isActive ? 'active' : 'inactive'\"\r\n      :data-orientation=\"context.orientation.value\"\r\n      @click=\"handleClick\"\r\n      :class=\"cn(\r\n      'rounded px-3 py-1.5 font-medium text-muted-foreground text-sm transition-colors',\r\n      'hover:bg-accent hover:text-accent-foreground',\r\n      'data-[state=active]:bg-accent data-[state=active]:text-foreground',\r\n      props.class\r\n    )\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpyViewport.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, type ComputedRef } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst props = defineProps({\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'div' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst context = inject<{ orientation: ComputedRef<string> }>('scroll-spy')\r\nif (!context) throw new Error('ScrollSpyViewport must be used within ScrollSpy')\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :data-orientation=\"context.orientation.value\"\r\n      :class=\"cn('flex flex-1 flex-col gap-8', props.class)\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/ScrollSpySection.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { inject, ref, onMounted, onBeforeUnmount, type ComputedRef } from 'vue'\r\nimport { Primitive } from 'reka-ui'\r\nimport { cn } from '@/lib/utils'\r\n\r\nconst props = defineProps({\r\n  value: { type: String, required: true },\r\n  asChild: { type: Boolean, default: false },\r\n  as: { type: String, default: 'div' },\r\n  class: { type: String, default: '' }\r\n})\r\n\r\nconst context = inject<{\r\n  registerSection: (id: string, el: HTMLElement) => void,\r\n  unregisterSection: (id: string) => void,\r\n  orientation: ComputedRef<string>\r\n}>('scroll-spy')\r\n\r\nif (!context) throw new Error('ScrollSpySection must be used within ScrollSpy')\r\n\r\nconst elementRef = ref<HTMLElement | null>(null)\r\n\r\nonMounted(() => {\r\n  if (elementRef.value) {\r\n    // If asChild is used, Primitive renders the slot content directly,\r\n    // but the ref still points to the DOM element if configured correctly.\r\n    // However, with reka-ui Primitive, the ref usually works on the underlying element.\r\n    // If using a component as child, ensure it forwards refs.\r\n    context.registerSection(props.value, elementRef.value.$el || elementRef.value)\r\n  }\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  context.unregisterSection(props.value)\r\n})\r\n</script>\r\n\r\n<template>\r\n  <Primitive\r\n      ref=\"elementRef\"\r\n      :as=\"as\"\r\n      :as-child=\"asChild\"\r\n      :id=\"value\"\r\n      :data-orientation=\"context.orientation.value\"\r\n      :class=\"props.class\"\r\n  >\r\n    <slot />\r\n  </Primitive>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "scroll-spy/index.ts",
      "content": "export { default as ScrollSpy } from './ScrollSpy.vue'\n",
      "type": "registry:ui"
    }
  ]
}