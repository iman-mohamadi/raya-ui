{
  "name": "gravity-stars",
  "type": "registry:ui",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "gravity-stars/GravityStars.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { ref, onMounted, onUnmounted, watch } from 'vue'\r\nimport { cn } from '@/lib/utils'\r\n\r\ntype MouseGravity = 'attract' | 'repel'\r\ntype GlowAnimation = 'instant' | 'ease' | 'spring'\r\ntype StarsInteractionType = 'bounce' | 'merge'\r\n\r\ninterface Particle {\r\n  x: number\r\n  y: number\r\n  vx: number\r\n  vy: number\r\n  size: number\r\n  opacity: number\r\n  baseOpacity: number\r\n  mass: number\r\n  glowMultiplier: number\r\n  glowVelocity: number\r\n}\r\n\r\nconst props = withDefaults(defineProps<{\r\n  starsCount?: number\r\n  starsSize?: number\r\n  starsOpacity?: number\r\n  glowIntensity?: number\r\n  glowAnimation?: GlowAnimation\r\n  movementSpeed?: number\r\n  mouseInfluence?: number\r\n  mouseGravity?: MouseGravity\r\n  gravityStrength?: number\r\n  starsInteraction?: boolean\r\n  starsInteractionType?: StarsInteractionType\r\n  class?: string\r\n}>(), {\r\n  starsCount: 75,\r\n  starsSize: 2,\r\n  starsOpacity: 0.75,\r\n  glowIntensity: 15,\r\n  glowAnimation: 'ease',\r\n  movementSpeed: 0.3,\r\n  mouseInfluence: 100,\r\n  mouseGravity: 'attract',\r\n  gravityStrength: 75,\r\n  starsInteraction: false,\r\n  starsInteractionType: 'bounce'\r\n})\r\n\r\nconst containerRef = ref<HTMLDivElement | null>(null)\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null)\r\nconst dpr = ref(1)\r\n\r\n// Non-reactive state for performance\r\nlet animId: number | null = null\r\nconst stars: Particle[] = []\r\n// Initialize off-screen so no stars are attracted on load\r\nconst mouse = { x: -9999, y: -9999 }\r\nconst canvasSize = { width: 800, height: 600 }\r\n\r\nconst readColor = () => {\r\n  if (!containerRef.value) return '#ffffff'\r\n  const cs = window.getComputedStyle(containerRef.value)\r\n  return cs.color || '#ffffff'\r\n}\r\n\r\nconst initStars = (w: number, h: number) => {\r\n  stars.length = 0 // Clear existing\r\n  for (let i = 0; i < props.starsCount; i++) {\r\n    const angle = Math.random() * Math.PI * 2\r\n    const speed = props.movementSpeed * (0.5 + Math.random() * 0.5)\r\n    stars.push({\r\n      x: Math.random() * w,\r\n      y: Math.random() * h,\r\n      vx: Math.cos(angle) * speed,\r\n      vy: Math.sin(angle) * speed,\r\n      size: Math.random() * props.starsSize + 1,\r\n      opacity: props.starsOpacity,\r\n      baseOpacity: props.starsOpacity,\r\n      mass: Math.random() * 0.5 + 0.5,\r\n      glowMultiplier: 1,\r\n      glowVelocity: 0\r\n    })\r\n  }\r\n}\r\n\r\nconst redistributeStars = (w: number, h: number) => {\r\n  stars.forEach(p => {\r\n    p.x = Math.random() * w\r\n    p.y = Math.random() * h\r\n  })\r\n}\r\n\r\nconst resizeCanvas = () => {\r\n  if (!containerRef.value || !canvasRef.value) return\r\n\r\n  const rect = containerRef.value.getBoundingClientRect()\r\n  const nextDpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2))\r\n  dpr.value = nextDpr\r\n\r\n  canvasSize.width = rect.width\r\n  canvasSize.height = rect.height\r\n\r\n  canvasRef.value.width = Math.max(1, Math.floor(rect.width * nextDpr))\r\n  canvasRef.value.height = Math.max(1, Math.floor(rect.height * nextDpr))\r\n  canvasRef.value.style.width = `${rect.width}px`\r\n  canvasRef.value.style.height = `${rect.height}px`\r\n\r\n  if (stars.length === 0) {\r\n    initStars(rect.width, rect.height)\r\n  } else {\r\n    redistributeStars(rect.width, rect.height)\r\n  }\r\n}\r\n\r\nconst handlePointerMove = (e: MouseEvent | TouchEvent) => {\r\n  if (!canvasRef.value) return\r\n  const rect = canvasRef.value.getBoundingClientRect()\r\n  let clientX = 0\r\n  let clientY = 0\r\n\r\n  if ('touches' in e && e.touches.length > 0) {\r\n    clientX = e.touches[0].clientX\r\n    clientY = e.touches[0].clientY\r\n  } else if ('clientX' in e) {\r\n    clientX = e.clientX\r\n    clientY = e.clientY\r\n  }\r\n\r\n  mouse.x = clientX - rect.left\r\n  mouse.y = clientY - rect.top\r\n}\r\n\r\n// FIX: Reset mouse position when leaving the container\r\nconst handlePointerLeave = () => {\r\n  mouse.x = -9999\r\n  mouse.y = -9999\r\n}\r\n\r\nconst updateStars = () => {\r\n  const w = canvasSize.width\r\n  const h = canvasSize.height\r\n\r\n  for (let i = 0; i < stars.length; i++) {\r\n    const p = stars[i]\r\n\r\n    const dx = mouse.x - p.x\r\n    const dy = mouse.y - p.y\r\n    const dist = Math.hypot(dx, dy)\r\n\r\n    if (dist < props.mouseInfluence && dist > 0) {\r\n      const force = (props.mouseInfluence - dist) / props.mouseInfluence\r\n      const nx = dx / dist\r\n      const ny = dy / dist\r\n      const g = force * (props.gravityStrength * 0.001)\r\n\r\n      if (props.mouseGravity === 'attract') {\r\n        p.vx += nx * g\r\n        p.vy += ny * g\r\n      } else {\r\n        p.vx -= nx * g\r\n        p.vy -= ny * g\r\n      }\r\n\r\n      p.opacity = Math.min(1, p.baseOpacity + force * 0.4)\r\n      const targetGlow = 1 + force * 2\r\n      const currentGlow = p.glowMultiplier\r\n\r\n      if (props.glowAnimation === 'instant') {\r\n        p.glowMultiplier = targetGlow\r\n      } else if (props.glowAnimation === 'ease') {\r\n        p.glowMultiplier = currentGlow + (targetGlow - currentGlow) * 0.15\r\n      } else {\r\n        const spring = (targetGlow - currentGlow) * 0.2\r\n        p.glowVelocity = p.glowVelocity * 0.85 + spring\r\n        p.glowMultiplier = currentGlow + p.glowVelocity\r\n      }\r\n    } else {\r\n      // Decay / Reset logic\r\n      p.opacity = Math.max(p.baseOpacity * 0.3, p.opacity - 0.02)\r\n      const targetGlow = 1\r\n      const currentGlow = p.glowMultiplier\r\n\r\n      if (props.glowAnimation === 'instant') {\r\n        p.glowMultiplier = targetGlow\r\n      } else if (props.glowAnimation === 'ease') {\r\n        p.glowMultiplier = Math.max(1, currentGlow + (targetGlow - currentGlow) * 0.08)\r\n      } else {\r\n        const spring = (targetGlow - currentGlow) * 0.15\r\n        p.glowVelocity = p.glowVelocity * 0.9 + spring\r\n        p.glowMultiplier = Math.max(1, currentGlow + p.glowVelocity)\r\n      }\r\n    }\r\n\r\n    if (props.starsInteraction) {\r\n      for (let j = i + 1; j < stars.length; j++) {\r\n        const o = stars[j]\r\n        const dx2 = o.x - p.x\r\n        const dy2 = o.y - p.y\r\n        const d = Math.hypot(dx2, dy2)\r\n        const minD = p.size + o.size + 5\r\n\r\n        if (d < minD && d > 0) {\r\n          if (props.starsInteractionType === 'bounce') {\r\n            const nx = dx2 / d\r\n            const ny = dy2 / d\r\n            const rvx = p.vx - o.vx\r\n            const rvy = p.vy - o.vy\r\n            const speed = rvx * nx + rvy * ny\r\n\r\n            if (speed >= 0) {\r\n              const impulse = (2 * speed) / (p.mass + o.mass)\r\n              p.vx -= impulse * o.mass * nx\r\n              p.vy -= impulse * o.mass * ny\r\n              o.vx += impulse * p.mass * nx\r\n              o.vy += impulse * p.mass * ny\r\n\r\n              const overlap = minD - d\r\n              p.x -= nx * overlap * 0.5\r\n              p.y -= ny * overlap * 0.5\r\n              o.x += nx * overlap * 0.5\r\n              o.y += ny * overlap * 0.5\r\n            }\r\n          } else {\r\n            const mergeForce = (minD - d) / minD\r\n            p.glowMultiplier += mergeForce * 0.5\r\n            o.glowMultiplier += mergeForce * 0.5\r\n            const af = mergeForce * 0.01\r\n            p.vx += dx2 * af\r\n            p.vy += dy2 * af\r\n            o.vx -= dx2 * af\r\n            o.vy -= dy2 * af\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    p.x += p.vx\r\n    p.y += p.vy\r\n\r\n    // Ambient Brownian motion\r\n    p.vx += (Math.random() - 0.5) * 0.001\r\n    p.vy += (Math.random() - 0.5) * 0.001\r\n\r\n    // Friction\r\n    p.vx *= 0.999\r\n    p.vy *= 0.999\r\n\r\n    // Wrap around\r\n    if (p.x < 0) p.x = w\r\n    if (p.x > w) p.x = 0\r\n    if (p.y < 0) p.y = h\r\n    if (p.y > h) p.y = 0\r\n  }\r\n}\r\n\r\nconst drawStars = (ctx: CanvasRenderingContext2D) => {\r\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\r\n  const color = readColor()\r\n\r\n  for (const p of stars) {\r\n    ctx.save()\r\n    // Scale position by DPR\r\n    ctx.shadowColor = color\r\n    ctx.shadowBlur = props.glowIntensity * p.glowMultiplier * 2\r\n    ctx.globalAlpha = p.opacity\r\n    ctx.fillStyle = color\r\n    ctx.beginPath()\r\n    ctx.arc(p.x * dpr.value, p.y * dpr.value, p.size * dpr.value, 0, Math.PI * 2)\r\n    ctx.fill()\r\n    ctx.restore()\r\n  }\r\n}\r\n\r\nconst animate = () => {\r\n  if (!canvasRef.value) return\r\n  const ctx = canvasRef.value.getContext('2d')\r\n  if (!ctx) return\r\n\r\n  updateStars()\r\n  drawStars(ctx)\r\n  animId = requestAnimationFrame(animate)\r\n}\r\n\r\nonMounted(() => {\r\n  resizeCanvas()\r\n  const ro = new ResizeObserver(resizeCanvas)\r\n  if (containerRef.value) ro.observe(containerRef.value)\r\n  window.addEventListener('resize', resizeCanvas)\r\n\r\n  animId = requestAnimationFrame(animate)\r\n\r\n  onUnmounted(() => {\r\n    if (animId) cancelAnimationFrame(animId)\r\n    window.removeEventListener('resize', resizeCanvas)\r\n    ro.disconnect()\r\n  })\r\n})\r\n\r\nwatch([\r\n  () => props.starsCount,\r\n  () => props.movementSpeed,\r\n  () => props.starsSize\r\n], () => {\r\n  initStars(canvasSize.width, canvasSize.height)\r\n})\r\n</script>\r\n\r\n<template>\r\n  <div\r\n      ref=\"containerRef\"\r\n      :class=\"cn('relative size-full overflow-hidden', props.class)\"\r\n      @mousemove=\"handlePointerMove\"\r\n      @touchmove=\"handlePointerMove\"\r\n      @mouseleave=\"handlePointerLeave\"\r\n  >\r\n    <canvas ref=\"canvasRef\" class=\"block w-full h-full\" />\r\n  </div>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "gravity-stars/index.ts",
      "content": "export { default as GravityStars } from './GravityStars.vue'\n",
      "type": "registry:ui"
    }
  ]
}