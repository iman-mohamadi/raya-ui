{
  "name": "dotted-glow-background",
  "type": "registry:ui",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "dotted-glow-background/DottedGlowBackground.vue",
      "content": "<script setup lang=\"ts\">\r\nimport { ref, onMounted, onBeforeUnmount, watch } from 'vue'\r\nimport { cn } from '@/lib/utils'\r\n\r\ninterface Props {\r\n  class?: string\r\n  /** distance between dot centers in pixels */\r\n  gap?: number\r\n  /** base radius of each dot in CSS px */\r\n  radius?: number\r\n  /** dot color (will pulse by alpha) */\r\n  color?: string\r\n  /** optional dot color for dark mode */\r\n  darkColor?: string\r\n  /** shadow/glow color for bright dots */\r\n  glowColor?: string\r\n  /** optional glow color for dark mode */\r\n  darkGlowColor?: string\r\n  /** optional CSS variable name for light dot color (e.g. --color-zinc-900) */\r\n  colorLightVar?: string\r\n  /** optional CSS variable name for dark dot color (e.g. --color-zinc-100) */\r\n  colorDarkVar?: string\r\n  /** optional CSS variable name for light glow color */\r\n  glowColorLightVar?: string\r\n  /** optional CSS variable name for dark glow color */\r\n  glowColorDarkVar?: string\r\n  /** global opacity for the whole layer */\r\n  opacity?: number\r\n  /** background radial fade opacity (0 = transparent background) */\r\n  backgroundOpacity?: number\r\n  /** minimum per-dot speed in rad/s */\r\n  speedMin?: number\r\n  /** maximum per-dot speed in rad/s */\r\n  speedMax?: number\r\n  /** global speed multiplier for all dots */\r\n  speedScale?: number\r\n}\r\n\r\nconst props = withDefaults(defineProps<Props>(), {\r\n  gap: 12,\r\n  radius: 2,\r\n  color: 'rgba(0,0,0,0.7)',\r\n  glowColor: 'rgba(0, 170, 255, 0.85)',\r\n  opacity: 0.6,\r\n  backgroundOpacity: 0,\r\n  speedMin: 0.4,\r\n  speedMax: 1.3,\r\n  speedScale: 1,\r\n})\r\n\r\nconst canvasRef = ref<HTMLCanvasElement | null>(null)\r\nconst containerRef = ref<HTMLDivElement | null>(null)\r\nconst resolvedColor = ref<string>(props.color)\r\nconst resolvedGlowColor = ref<string>(props.glowColor)\r\n\r\n// --- State ---\r\nlet dots: { x: number; y: number; phase: number; speed: number }[] = []\r\nlet rafId = 0\r\nlet stopAnimation = false\r\nlet resizeObserver: ResizeObserver | null = null\r\nlet mutationObserver: MutationObserver | null = null\r\n\r\n// --- Helpers ---\r\n\r\nconst resolveCssVariable = (el: Element, variableName?: string): string | null => {\r\n  if (!variableName) return null\r\n  const normalized = variableName.startsWith('--') ? variableName : `--${variableName}`\r\n  const style = getComputedStyle(el)\r\n  const fromEl = style.getPropertyValue(normalized).trim()\r\n  if (fromEl) return fromEl\r\n  const root = document.documentElement\r\n  const fromRoot = getComputedStyle(root).getPropertyValue(normalized).trim()\r\n  return fromRoot || null\r\n}\r\n\r\nconst detectDarkMode = (): boolean => {\r\n  if (typeof document === 'undefined') return false\r\n  const root = document.documentElement\r\n  if (root.classList.contains('dark')) return true\r\n  if (root.classList.contains('light')) return false\r\n  return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches\r\n}\r\n\r\nconst computeColors = () => {\r\n  if (!containerRef.value) return\r\n\r\n  const isDark = detectDarkMode()\r\n  let nextColor = props.color\r\n  let nextGlow = props.glowColor\r\n\r\n  if (isDark) {\r\n    const varDot = resolveCssVariable(containerRef.value, props.colorDarkVar)\r\n    const varGlow = resolveCssVariable(containerRef.value, props.glowColorDarkVar)\r\n    nextColor = varDot || props.darkColor || nextColor\r\n    nextGlow = varGlow || props.darkGlowColor || nextGlow\r\n  } else {\r\n    const varDot = resolveCssVariable(containerRef.value, props.colorLightVar)\r\n    const varGlow = resolveCssVariable(containerRef.value, props.glowColorLightVar)\r\n    nextColor = varDot || nextColor\r\n    nextGlow = varGlow || nextGlow\r\n  }\r\n\r\n  resolvedColor.value = nextColor\r\n  resolvedGlowColor.value = nextGlow\r\n}\r\n\r\n// Regenerate dot positions. Called on resize or when gap/speed changes.\r\nconst regenDots = () => {\r\n  if (!containerRef.value) return\r\n\r\n  const { width, height } = containerRef.value.getBoundingClientRect()\r\n  dots = []\r\n\r\n  const cols = Math.ceil(width / props.gap) + 2\r\n  const rows = Math.ceil(height / props.gap) + 2\r\n  const min = Math.min(props.speedMin, props.speedMax)\r\n  const max = Math.max(props.speedMin, props.speedMax)\r\n\r\n  for (let i = -1; i < cols; i++) {\r\n    for (let j = -1; j < rows; j++) {\r\n      // offset every other row\r\n      const x = i * props.gap + (j % 2 === 0 ? 0 : props.gap * 0.5)\r\n      const y = j * props.gap\r\n      const phase = Math.random() * Math.PI * 2\r\n      const span = Math.max(max - min, 0)\r\n      const speed = min + Math.random() * span\r\n      dots.push({ x, y, phase, speed })\r\n    }\r\n  }\r\n}\r\n\r\nconst initCanvas = () => {\r\n  const el = canvasRef.value\r\n  const container = containerRef.value\r\n  if (!el || !container) return\r\n\r\n  const ctx = el.getContext('2d')\r\n  if (!ctx) return\r\n\r\n  const dpr = Math.max(1, window.devicePixelRatio || 1)\r\n\r\n  // Resize handler\r\n  const resize = () => {\r\n    const { width, height } = container.getBoundingClientRect()\r\n    el.width = Math.max(1, Math.floor(width * dpr))\r\n    el.height = Math.max(1, Math.floor(height * dpr))\r\n    el.style.width = `${Math.floor(width)}px`\r\n    el.style.height = `${Math.floor(height)}px`\r\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0)\r\n\r\n    regenDots()\r\n  }\r\n\r\n  // Setup Observer\r\n  resizeObserver = new ResizeObserver(() => resize())\r\n  resizeObserver.observe(container)\r\n  resize()\r\n\r\n  let last = performance.now()\r\n\r\n  const draw = (now: number) => {\r\n    if (stopAnimation) return\r\n    const dt = (now - last) / 1000\r\n    last = now\r\n\r\n    // Safety check if element is gone\r\n    if (!el || !container) return\r\n    const { width, height } = el\r\n\r\n    ctx.clearRect(0, 0, width, height)\r\n    ctx.globalAlpha = props.opacity\r\n\r\n    // Optional background fade\r\n    if (props.backgroundOpacity > 0) {\r\n      // We need client rect for gradient center, or just use canvas dims\r\n      const cw = width / dpr\r\n      const ch = height / dpr\r\n\r\n      const grad = ctx.createRadialGradient(\r\n          cw * 0.5,\r\n          ch * 0.4,\r\n          Math.min(cw, ch) * 0.1,\r\n          cw * 0.5,\r\n          ch * 0.5,\r\n          Math.max(cw, ch) * 0.7\r\n      )\r\n      grad.addColorStop(0, 'rgba(0,0,0,0)')\r\n      grad.addColorStop(1, `rgba(0,0,0,${Math.min(Math.max(props.backgroundOpacity, 0), 1)})`)\r\n      ctx.fillStyle = grad\r\n      ctx.fillRect(0, 0, cw, ch)\r\n    }\r\n\r\n    // Animate dots\r\n    ctx.save()\r\n    ctx.fillStyle = resolvedColor.value\r\n\r\n    const time = (now / 1000) * Math.max(props.speedScale, 0)\r\n\r\n    for (let i = 0; i < dots.length; i++) {\r\n      const d = dots[i]\r\n      const mod = (time * d.speed + d.phase) % 2\r\n      const lin = mod < 1 ? mod : 2 - mod\r\n      const a = 0.25 + 0.55 * lin\r\n\r\n      if (a > 0.6) {\r\n        const glow = (a - 0.6) / 0.4\r\n        ctx.shadowColor = resolvedGlowColor.value\r\n        ctx.shadowBlur = 6 * glow\r\n      } else {\r\n        ctx.shadowColor = 'transparent'\r\n        ctx.shadowBlur = 0\r\n      }\r\n\r\n      ctx.globalAlpha = a * props.opacity\r\n      ctx.beginPath()\r\n      ctx.arc(d.x, d.y, props.radius, 0, Math.PI * 2)\r\n      ctx.fill()\r\n    }\r\n    ctx.restore()\r\n    rafId = requestAnimationFrame(draw)\r\n  }\r\n\r\n  rafId = requestAnimationFrame(draw)\r\n}\r\n\r\n// --- Watchers ---\r\n\r\nwatch(\r\n    () => [props.color, props.darkColor, props.glowColor, props.darkGlowColor, props.colorLightVar, props.colorDarkVar],\r\n    computeColors\r\n)\r\n\r\n// Re-generate grid when structural props change\r\nwatch(\r\n    () => [props.gap, props.speedMin, props.speedMax],\r\n    () => {\r\n      regenDots()\r\n    }\r\n)\r\n\r\n// --- Lifecycle ---\r\n\r\nonMounted(() => {\r\n  computeColors()\r\n  initCanvas()\r\n\r\n  mutationObserver = new MutationObserver((mutations) => {\r\n    for (const m of mutations) {\r\n      if (m.type === 'attributes' && (m.attributeName === 'class' || m.attributeName === 'style')) {\r\n        computeColors()\r\n      }\r\n    }\r\n  })\r\n  mutationObserver.observe(document.documentElement, {\r\n    attributes: true,\r\n    attributeFilter: ['class', 'style'],\r\n  })\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  stopAnimation = true\r\n  cancelAnimationFrame(rafId)\r\n  if (resizeObserver) resizeObserver.disconnect()\r\n  if (mutationObserver) mutationObserver.disconnect()\r\n})\r\n</script>\r\n\r\n<template>\r\n  <div\r\n      ref=\"containerRef\"\r\n      :class=\"cn('absolute inset-0 z-0', props.class)\"\r\n  >\r\n    <canvas\r\n        ref=\"canvasRef\"\r\n        class=\"block h-full w-full\"\r\n    />\r\n    <slot />\r\n  </div>\r\n</template>",
      "type": "registry:ui"
    },
    {
      "path": "dotted-glow-background/index.ts",
      "content": "export { default as DottedGlowBackground } from './DottedGlowBackground.vue'\n",
      "type": "registry:ui"
    }
  ]
}